import sys
from functools import reduce
from operator import mul
import numpy as np
import onnx
from onnx import numpy_helper, shape_inference
from operators import *

inOnnxFile = ''
outCFile = ''

def die(msg):
  sys.stderr.write(msg)
  sys.stderr.write('\n')
  sys.exit(-1)

def value_info_to_dtype_shape(value_info):
  return tuple([x.dim_value for x in value_info.type.tensor_type.shape.dim]), value_info.type.tensor_type.elem_type

def main():
  global inOnnxFile, outCFile
  if len(sys.argv) != 3:
    print("""
            Usage: python %s in.onnx out.c
          """ % sys.argv[0])
  else:
    inOnnxFile = sys.argv[1]
    outCFile = sys.argv[2]

    try:
      _model = onnx.load(inOnnxFile)
      model = shape_inference.infer_shapes(_model)
    except Exception as err:
      die('load model error: \n\t' + str(err))
    
    layers = list()

    # load constants
    for weight in model.graph.initializer:
      array = numpy_helper.to_array(weight)
      shape = array.shape
      layers.append(ConstantLayer(weight.name, shape, weight.data_type, array))

    in_layer, out_layer = [], []
    # create input layer
    for inp in model.graph.input:
      in_layer.append(Layer(inp.name,
                        tuple([x.dim_value for x in inp.type.tensor_type.shape.dim]),
                        inp.type.tensor_type.elem_type))
    layers.extend(in_layer)

    for vi in model.graph.value_info:
      layers.append(Layer(vi.name, *value_info_to_dtype_shape(vi)))

    for inp in model.graph.output:
      out_layer.append(Layer(inp.name,
                        tuple([x.dim_value for x in inp.type.tensor_type.shape.dim]),
                        inp.type.tensor_type.elem_type))
    layers.extend(out_layer)

    nodes = []
    # create operators
    for node in model.graph.node:
      new_node = CNode.getOperator(node)
      new_node.update(layers)
      nodes.append(new_node)
      
    
#     getSize = lambda shape:reduce(mul, shape.shape)
#     print(list(map(getSize, layers)))
#     print(list(map(str, layers)))
#     print('Constant Values: {}'.format())
    
#     for l in layers:
#       print(l.toArray())
    with open(outCFile, 'w+') as f:
      f.write('// Auto generated by {}\n\n'.format(sys.argv[0]))
      f.write('#include <stdint.h>\n')
      f.write('#include <string.h>\n\n')
      for l in layers:
        f.write('// layer: {} shape: {}\n'.format(l.name, l.shape))
        f.write(l.toArray())
        f.write('\n\n')
      
      for node in nodes:
        f.write('// node\n')
        f.write(node.toOpSrc())
        f.write('\n\n')
        
      f.write("""void Model(void* input, void* output)
      {{
        memcpy({in_layer}, input, sizeof({in_layer}));
        {graph}
        memcpy(output, {out_layer}, sizeof({out_layer}));
      }}
      """.format(in_layer=in_layer[0].c_name, out_layer=out_layer[0].c_name, graph='\n'.join(map(lambda n:n.toCallSrc(), nodes))))

if __name__ == "__main__":
    main()