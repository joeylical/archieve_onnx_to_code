import os
import sys
from functools import reduce
from operator import mul
import numpy as np
import onnx
from onnx import numpy_helper, shape_inference
from operators import *

from time import time
last_time = time()
def print_time(title):
  global last_time
  t = time()
  # print(title, t - last_time)
  last_time = t

inOnnxFile = ''
outCFile = ''

def die(msg):
  sys.stderr.write(msg)
  sys.stderr.write('\n')
  sys.exit(-1)

def value_info_to_dtype_shape(value_info):
  return tuple([x.dim_value for x in value_info.type.tensor_type.shape.dim]), value_info.type.tensor_type.elem_type

def main():
  global inOnnxFile, outCFile
  if len(sys.argv) != 3:
    print("""
            Usage: python %s in.onnx out.c
          """ % sys.argv[0])
  else:
    inOnnxFile = sys.argv[1]
    outCFile = sys.argv[2]

    try:
      _model = onnx.load(inOnnxFile)
      print_time('end load model')
      model = shape_inference.infer_shapes(_model)
      print_time('end infer shapes')
    except Exception as err:
      die('load model error: \n\t' + str(err))
    
    layers = list()
    
    # load constants
    for weight in model.graph.initializer:
      shape = tuple(weight.dims)
#       layers.append(ConstantLayer(weight.name, shape, weight.data_type, np.array([0]))) # numpy_helper.to_array(weight)))
      layers.append(ConstantLayer(weight.name, shape, weight.data_type, numpy_helper.to_array(weight)))

    print_time('end load weight')
    in_layer, out_layer = [], []
    # create input layer
    for inp in model.graph.input:
      in_layer.append(Layer(inp.name,
                        tuple([x.dim_value for x in inp.type.tensor_type.shape.dim]),
                        inp.type.tensor_type.elem_type))
    layers.extend(in_layer)

    print_time('end load layer')
    for vi in model.graph.value_info:
      layers.append(Layer(vi.name, *value_info_to_dtype_shape(vi)))

    for inp in model.graph.output:
      out_layer.append(Layer(inp.name,
                        tuple([x.dim_value for x in inp.type.tensor_type.shape.dim]),
                        inp.type.tensor_type.elem_type))
    layers.extend(out_layer)
    print_time('end load i/o')
    nodes = []

    size = [sum((i.size for i in in_layer)), 0]
    current_buf = 0
    last_alter_node = 0
    # create operators
    for i, node in enumerate(model.graph.node):
      new_node = CNode.getOperator(node)
      if new_node is None:
        print('{}'.format(node.name))
      new_node.update(layers)
      nodes.append(new_node)

      if new_node.inplace:
        if new_node.output[0].size > size[current_buf]:
          size[current_buf] = new_node.output[0].size
      else:
        last_alter_node = i
        if new_node.output[0].size > size[current_buf]:
          size[current_buf] = new_node.output[0].size
        current_buf = 1-current_buf
    print_time('end load nodes')
    with open(outCFile, 'w+') as f:
      f.write('// Auto generated by {}\n\n'.format(sys.argv[0]))
      f.write('#include <stdint.h>\n')
      f.write('#include <string.h>\n')
      f.write('#include <limits.h>\n')
      f.write('#include <float.h>\n')
      f.write('#include <math.h>')
      f.write('\n\n')

      f.write('#define float_IS_ZERO(value) ((value) > -0.0001f && (value) < 0.0001f)\n')
      f.write('#define uint8_t_IS_ZERO(value) (!(value))\n')
      f.write('\n\n')

      for l in layers:
        if isinstance(l, ConstantLayer):
          f.write('// layer: {} shape: {}\n'.format(l.name, l.shape))
          f.write(l.toArray())
          f.write('\n\n')
      
      f.write('{ctype} buf1[{size}];\n'.format(ctype=c_data_type[layers[0].data_type], size=size[0]))
      f.write('{ctype} buf2[{size}];\n'.format(ctype=c_data_type[layers[0].data_type], size=size[1]))
      f.write('\n\n')

      for node in nodes:
        op = node.toOpSrc()
        if len(node.toOpSrc()) > 0:
          f.write('//node\n')
          f.write(op)
          f.write('\n\n')
        
      f.write("void Model(void* input, void* output)\n{\n")
      current_buf = 0
      for i, node in enumerate(nodes):
        if i == 0:
          f.write('  ')
          f.write(node.toCallSrc('input', 'buf{}'.format(current_buf+1)))
          f.write('\n')
        elif i == last_alter_node:
          f.write('  ')
          f.write(node.toCallSrc('buf{}'.format(current_buf+1), 'output'))
          f.write('\n')
        elif node.inplace:
          caller = node.toCallSrc('buf{}'.format(current_buf+1), 'NULL')
          if len(caller) > 0:
            f.write('  ')
            f.write(caller)
            f.write('\n')
        else:
          f.write('  ')
          f.write(node.toCallSrc('buf{}'.format(current_buf+1), 'buf{}'.format(1-current_buf+1)))
          f.write('\n')
          current_buf = 1 - current_buf
        
      f.write('}\n\n')
    print_time('end save file')
    os.system('indent -kr -br -i 2 {} >NUL 2>&1'.format(outCFile))

if __name__ == "__main__":
    main()